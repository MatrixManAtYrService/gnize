"""
# Purpose

This module implements `cog`.  It's short for cognize, which is what happens in
your mind the first time that you see a new thing.  If you see that thing a
second time, you might recognize it--which is a separate sort of thing. That's
what the `recog` command line utility is for.

Presumably, the thing you want to cognize isn't alone.  Maybe it is bundled
with ads or other malware.  Maybe it it split by a pagniation boundary.
Whatevever the extra data is, we'll call the whole thing "noise" and whatever
subset you want to cognize now (and recognize later) we'll call "signal".

`cog` will create artifacts that you (or someone else) can use to identify the
signal later on--even if it is surrounded by (or lightly corruptedby ) by
different noise.

There are two components to this:

- fingerprints (stored in ~/.gnize/fingerprints.db)
- canvasses (stored in ~/.gnize/canvasses)

The fingerprints are generated by features.py, they're a list of hashes ordered
by their appearence in the noise.  Each time you cog(nize) you create a single
canvas, which is a list of strings which together make up the signal.
Canvasses aren't a single string because the signal as found in the noise might
have noise in ths middle.  For instance, here's some noise:

    asdfsdaf45646546This is the song that never ends yes it goes on
    and on my friends some people started signing it __^%%$^%k not
    knowning what it was and they'll continue singing it forever
    just because assxccjjasoadflkasdflkjsdlj.

The cognizer has some freedom in how they extract this signal, but a reasonable
choice would be:

    ["This is the song that never ends yes it goes on and on my friends some people started signing it ",
     "not knowning what it was and they'll continue singing it forever just because"]

A recognizer of the "same" signal, couched in different noise might break it up
differently, and that might corrupt some of the fingerprints that they
calculate, but unless their corruption is severe, they're likely to reidentify
enough of the same fingerprints that they can find the original canvas (and
whatever annotations go with it).

The possibility of having several canvasses for what ammounts to the "same"
signal, and building consensus on one to treat as cannonical, is a separate
problem.  For now we just want create canvasses and query for them by fingerprints.
"""

import atexit
import sys
from contextlib import redirect_stdout
from dataclasses import dataclass
from datetime import datetime
from enum import Enum, auto
from io import StringIO
from pprint import pformat
from textwrap import dedent, indent
from typing import Iterator, List, Tuple, Union, Optional

import traceback
import yaml
from intervaltree import Interval, IntervalTree
from tabulate import tabulate

from gnize import dotdir
from prompt_toolkit import Application
from prompt_toolkit.buffer import Buffer
from prompt_toolkit.document import Document
from prompt_toolkit.enums import EditingMode
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.key_binding.vi_state import InputMode
from prompt_toolkit.layout import Layout
from prompt_toolkit.layout.containers import HSplit, VSplit, Window, WindowAlign
from prompt_toolkit.layout.controls import BufferControl, FormattedTextControl
from prompt_toolkit.lexers import Lexer
from prompt_toolkit.widgets import Frame, HorizontalLine


class Kind(Enum):
    "cognized noise is either..."

    noise = auto()
    signal = auto()
    parameter = auto()


subcanvas_color = {
    Kind.signal: "#B5B900",
    Kind.parameter: "#2aa198",
    Kind.noise: "#586e75",
}


@dataclass
class CharState:
    selected: bool
    kind: Kind
    char: str
    styled_char: Tuple[str, str]


@dataclass
class Data:
    "Each interval of noise refers to..."

    kind: Kind
    data: Union[str, Tuple[str, str]]

    def summary(
        self, interval: Interval, cursor_start=0, cursor_stop=None
    ) -> List[CharState]:

        selection_end = cursor_stop or cursor_start or 1
        selection = Interval(begin=cursor_start or 0, end=cursor_stop or cursor_start)
        unabridged = []
        for i, c in enumerate(interval.data.data):
            idx = i + interval.begin
            if c.isspace():
                c = " "

            selected = selection.contains_point(idx)

            color = subcanvas_color[interval.data.kind]
            if selected:
                color = f"{color} bold"

            unabridged.append(
                CharState(
                    selected=selected,
                    kind=interval.data.kind,
                    char=c,
                    styled_char=(color, c),
                )
            )

        width = 10
        part = int(width / 2) - 1

        if len(unabridged) > width:
            start = unabridged[:part]
            end = unabridged[-part:]
            omitted = unabridged[part:-part]

            if any(filter(lambda x: x.selected, omitted)):
                standin_selected = True
            else:
                standin_selected = False

            if any(filter(lambda x: x.kind == Kind.signal, unabridged)):
                standin_kind = Kind.signal
            else:
                standin_kind = Kind.noise

            standin = [
                CharState(
                    selected=standin_selected,
                    kind=standin_kind,
                    char="...",
                    styled_char=(subcanvas_color[standin_kind], "..."),
                )
            ]

        else:
            start = unabridged
            end = []
            standin = []

        return start + standin + end


@dataclass
class Error:
    original: str
    user_change: str

    def __hash__(self):
        return (self.original + self.user_change).__hash__()

    def __lt__(self, other):
        return (self.original + self.user_change) < other


def find_targeted(
    orig: str,
    change: str,
    cursor_pos: int,
    prev_cursor_pos: int,
    selections: List[Tuple[int, int]],
    prev_selections: List[Tuple[int, int]],
) -> Tuple[List[Tuple[int, int]], Optional[int]]:
    """
    Given two strings, the first being the original and the second
    being whatever change the user applied, find the bounds of the
    changes.

    Returns a pair:
     - list of changed ranges
     - new cursor position (or None)
    """

    # our goal is to figure out index-ranges for whatever was deleted
    lost_characters = len(orig) - len(change)
    debug(f"TARGETING: net char los: {lost_characters}")

    # align outpt with above label
    def dbg(message):
        debug(indent(str(message), prefix="           "))

    # is this what the user deleted?
    def fits(ranges):

        # what would go?
        maybe_deleted = []
        for r in ranges:
            maybe_deleted.append(orig[r[0] : r[1]])
        maybe_deleted_str = "\n--\n".join(maybe_deleted)
        range_str = ",".join([f"{x[0]}-{x[1]}" for x in ranges])
        dbg(
            f"candidate deletion {range_str}:\n"
            + indent(maybe_deleted_str, prefix="  ")
        )

        # what would stay?
        preserved = []
        end = len(noise)
        dbg("preserving")
        for prev_r, r in zip([(None, None)] + ranges, ranges):
            start = prev_r[1] or 0
            end = r[0]
            p_range = noise[start:end]
            dbg(indent(p_range, prefix="  "))
            preserved.append(p_range)
            dbg("  --")
        p_range = noise[end + 1 :]
        dbg(indent(p_range, prefix="  "))
        preserved.append(p_range)
        preserved_str = "".join(preserved)

        # show what's being compared
        comparisons = "\n--\n".join([change, preserved_str])
        dbg(f"comparing:\n" + indent(comparisons, prefix="  "))

        # if what would change is what actually changed
        if preserved_str == change:
            return True

    # if the user added characters (perhaps by a yank/put)
    # revert states, mark no changes
    if not lost_characters:
        return ([], None)

    # walk the deleted range
    # see which manipuluation to the noise makes it match the change
    candidate = None
    min_start = cursor_pos - lost_characters

    # maybe it started at the cursor position (x, dw, d$)
    candidate = (cursor_pos, cursor_pos + lost_characters)
    if fits([candidate]):
        dbg(f"marking from {candidate[0]} to {candidate[1]} ")
        return ([candidate], None)

    # maybe it started before the cursor position (dd, diw)
    else:
        for i in range(min_start, cursor_pos):
            if i >= 0:
                maybe_deleted = noise[i : i + lost_characters]
                dbg(f"trying: {min_start + i}-{cursor_pos}: ({maybe_deleted})")
                precandidate = (
                    change[i:cursor_pos] + change[cursor_pos + lost_characters - 1 :]
                )

                if noise[:i] + noise[i + lost_characters] == change:
                    candidate = (i, i + lost_characters)
                    break

    if candidate and len(prev_selections) <= 1:
        # if there were not previously multiple selections, then the
        # above match is correct, and so is the cursor position
        dbg(f"marking from {candidate[0]} to {candidate[1]} ")
        return ([candidate], None)

    else:
        # otherwise, try deleting all previous selections
        fragments = []
        for prev_sel, sel in zip([(None, None)] + prev_selections, prev_selections):
            not_del_start = prev_sel[1] or 0
            not_del_end = sel[0]
            fragments.append(noise[not_del_start:not_del_end])
        fragments = "".join(fragments)

        if "".join(fragments) == change:
            dbg(f"           marking previous selection")
            return (prev_selections, None)

        elif candidate:
            # or maybe the previous selections are irrelevant
            # go with the candidate found above
            dbg(f"           marking from {candidate[0]} to {candidate[1]} ")
            return ([candidate], None)

    raise NotImplementedError("failed to target changes")

    # first assume that there was only one change


def toggled(noise, state, toggled_ranges) -> List[Kind]:
    "The user has indicated a range, change the state for those chars"

    # initialize all chars as signal if no state is found
    if not state:
        debug(f"TOGGLED: state is uninitialized, marking all signal")
        return [Kind.signal for _ in noise]

    # which states are changing?
    targeted_states = set()
    targeted_indices = set()
    for i, s in enumerate(state):
        for tr in toggled_ranges:
            if i in tr:
                targeted_indices.add(i)
                targeted_states.add(s)

    # if none, exit early
    if not targeted_states:
        return state

    if any(filter(lambda x: x == Kind.signal, targeted_states)):
        # mark as noise if any are signal
        disposition = Kind.noise
    else:
        # otherwise mark as signal
        disposition = Kind.signal
    debug(f"         marking as {disposition}")

    for i in targeted_indices:
        state[i] = disposition
    return state


signal_kinds = [Kind.signal, Kind.parameter]
noise_kinds = [Kind.noise]


prev_char_states = []
char_states = []
debug_display = FormattedTextControl(text="")


def charstate_str():
    return "".join([{Kind.signal: "s", Kind.noise: "n"}[x] for x in char_states])


class SubcanvasLexer(Lexer):

    char_states: List[Kind] = []

    def lex_document(self, document):
        def get_line(lineno):

            line_start = line_start_idx[lineno]

            formatted_chars = [None] * len(document.lines[lineno])

            # set colors for this line
            for i, c in enumerate(document.lines[lineno]):
                char_no = line_start + i
                char_kind = SubcanvasLexer.char_states[char_no]
                char_color = subcanvas_color[char_kind]
                formatted_chars[i] = (char_color, c)

            return formatted_chars

        return get_line


class SubcanvasSummaryLexer(Lexer):

    cursor_start = 0
    cursor_stop = None
    it: IntervalTree = None

    def lex_document(self, document):
        def get_line(lineno):
            interval = sorted(SubcanvasSummaryLexer.it)[lineno]
            summary = interval.data.summary(
                interval,
                cursor_start=SubcanvasSummaryLexer.cursor_start,
                cursor_stop=SubcanvasSummaryLexer.cursor_stop,
            )

            return [s.styled_char for s in summary]

        return get_line


def format_event(event, previous_event=None):
    # shortens event for debug display
    def show(kv):
        k, v = kv
        if not str(v):
            return False
        if str(v)[-1] == ">":
            return False
        if str(v) == "None":
            return False
        if "do_stack" in k:
            return False
        if "validation" in k:
            return False
        if "completer" in k:
            return False
        if "_document_cache" in k:
            return False
        return True

    with StringIO() as buf, redirect_stdout(buf):
        print("event:")
        if not previous_event:
            tbl = list(map(list, filter(show, event.__dict__.items())))
            tbl_out = tabulate(tbl)
            tbl_out_simpler = "\n".join(tbl_out.split("\n")[1:-1])
            print(indent(tbl_out_simpler, prefix="    "))
        return buf.getvalue()


subcanvasses = []
subcanvas_summaries = Buffer()
subcanvasses_display = BufferControl(
    buffer=subcanvas_summaries, lexer=SubcanvasSummaryLexer()
)

prev_cursor_pos = 0
reentrancy = 0
iterations = 0

prev_event = None
prev_selection_ranges = None


class BufferUpdateException(Exception):
    pass


def update(event):
    global subcanvasses
    global subcanvasses_display
    global subcanvas_summaries
    global prev_char_states
    global char_states
    global debug_display
    global debug_buffer
    global prev_cursor_pos
    global reentrancy
    global prev_event
    global iterations
    global pending_debug_buffer
    global prev_selection_ranges

    # if this event's handler causes it to fire again before it is handled,
    # skip most of the handler until the first handling is completed
    reentrancy += 1
    if reentrancy == 1:
        iterations += 1

        # if something goes wrong below, write to debug output before
        # raising the exception
        try:

            # write event info to debug
            debug(f"iteration: {iterations}")
            debug(format_event(event))
            selection_ranges = list(event.document.selection_ranges())
            debug(f"selection: {selection_ranges}")
            if prev_selection_ranges:
                debug(f"prevous selection: {prev_selection_ranges}")

            cursor_pos = event._Buffer__cursor_position

            # look for user changes
            targeted_ranges, cursor_position_override = find_targeted(
                noise,
                buffer.text,
                cursor_pos,
                prev_cursor_pos,
                selection_ranges,
                prev_selection_ranges,
            )

            # update which characters are in/excluded based on what changed
            debug("char_states: " + str(char_states))
            char_states = toggled(noise, char_states, targeted_ranges)

            # show user recent changes
            try:
                intervals = get_subcanvasses(noise, char_states)
            except AlignmentError as err:
                debug_next(str(err))
                buffer.text = noise
                char_states = prev_char_states
            else:

                SubcanvasLexer.char_states = char_states
                SubcanvasSummaryLexer.it = intervals

                # show the user which characters are of which kind
                buffer.text = noise

                subcanvasses = sorted(intervals)

                def update_subcanvas_summaries(cursor_start, cursor_stop=None):
                    global subcanvas_summaries

                debug("charstate: " + charstate_str())

                # color summaries based on current selection
                if event.selection_state:
                    SubcanvasSummaryLexer.cursor_start = min(
                        event._Buffer__cursor_position,
                        event.selection_state.original_cursor_position,
                    )
                    SubcanvasSummaryLexer.cursor_stop = max(
                        event._Buffer__cursor_position,
                        event.selection_state.original_cursor_position,
                    )
                else:
                    SubcanvasSummaryLexer.cursor_start = event._Buffer__cursor_position

                # give interval starts, lexer will replace each with a summary
                interval_starts = []
                for subcanvas in subcanvasses:
                    interval_starts.append(str(subcanvas.begin))
                subcanvas_summaries.text = "\n".join(interval_starts)

                # if not cursor_position_override:
                #    if end and end > event._Buffer__cursor_position:
                #        debug(f"setting cursor_position: {end}")
                #        cursor_position_override = end

                # set cursor position
                debug(f"Cursor position override: {cursor_position_override}")
                buffer.cursor_position = (
                    cursor_position_override or event._Buffer__cursor_position
                )
                prev_cursor_pos = cursor_pos
                cursor_pos = buffer.cursor_position

        except Exception as ex:
            new_ex = BufferUpdateException(
                "\n---\n".join(
                    [pending_debug_buffer, debug_buffer, traceback.format_exc()]
                )
            )
            raise new_ex from ex
            # don't hide debug data just because we got an exception
            # print(pending_debug_buffer)
            # print(debug_buffer)
            # raise ex

    # run at the end of the outermost call
    reentrancy -= 1
    if not reentrancy:

        # populate debug_display
        debug_display.text = debug_buffer
        debug_buffer = "" or pending_debug_buffer
        if pending_debug_buffer:
            pending_debug_buffer = ""

        prev_event = event
        prev_char_states = char_states
        prev_selection_ranges = selection_ranges


class Direction(Enum):
    back = auto()
    forward = auto()


class AlignmentError(Exception):
    pass


def get_subcanvasses(noise, charstate) -> IntervalTree:

    if charstate == None:
        charstate = [Kind.signal] * len(noise)

    if len(noise) != len(charstate):
        raise AlignmentError(
            dedent(
                f"""
                we need a charstate for each noise char
                {noise} (len: {len(noise)})
                  !=
                {char_states} (len: {len(char_states)})
                """
            )
        )

    it = IntervalTree()
    begin = 0
    end = 0
    next_kind = None

    def gobble(kind, begin):
        "reached kind boundary, create a subcanvas for previous stuff"
        debug(f"gobbling from {begin} to {end} for {kind}:")
        debug(indent(noise[begin:end], prefix="    "))

        it[begin:end] = Data(kind=kind, data=noise[begin:end])
        begin = end + 1

    # for each char, maybe generate subcanvas for whatever preceeds it
    for i, _ in enumerate(noise):
        current = charstate[i]
        end = i + 1
        try:
            next_kind = charstate[i + 1]
        except IndexError:
            gobble(current, begin)

        if current and current != next_kind:
            gobble(current, begin)
            begin = i + 1

    return it


legend_left = dedent(
    """
    Done----Ctrl+D
    Cancel--Ctrl+C
    """
).strip("\n")

legend_center = dedent(
    """
    Editor--Ctrl+E
    """
).strip("\n")

legend_right = dedent(
    """
    Signals--Ctrl+[Shift]+S
    Gaps-----Ctrl+[Shift]+G
    """
).strip("\n")


debug_file = None


def close_debug_file():
    if debug_file:
        debug_file.close()


pending_debug_buffer = ""
debug_buffer = ""


def debug_next(message):
    global pending_debug_buffer

    if message[-1] != "\n":
        message += "\n"
    pending_debug_buffer += str(message)


def debug(message):
    global debug_buffer

    if message[-1] != "\n":
        message += "\n"

    if debug_file:
        if type(message) is not str:
            debug_file.write("----\n")
            debug_file.write(indent(pformat(message), prefix="    "))
            debug_file.write("\n\n")
        else:
            debug_file.write(dedent(message).strip() + "\n\n")
        debug_file.flush()
    debug_buffer += str(message)


def debug_dump():
    with open(config.runtime.debug_obj, "w") as f:
        f.write(
            yaml.dump(
                {
                    "states": list(
                        map(list, zip(noise, [x.name for x in char_states]))
                    ),
                    "subcanvasses": [x.data.data for x in subcanvasses],
                }
            )
        )


atexit.register(close_debug_file)

noise = ""
line_start_idx = {}
signal = ""
buffer = Buffer(on_text_changed=update, on_cursor_position_changed=update)

buffer_header = FormattedTextControl(
    text="Delete noise until only signal remains",
)
subcanvasses_header = FormattedTextControl(text="Signal")

selected_idx = 0

root_container = None
config = dotdir.make_or_get()


app = None


def make_canvas(_noise, args):

    global noise
    global debug_file
    global root_container

    noise = _noise  # + "\n"

    # lexers care about line numbers, so cache them
    idx = 0
    for i, n in enumerate(noise.split("\n")):
        line_start_idx[i] = idx
        idx = idx + len(n) + 1

    charstate = [Kind.signal for _ in _noise]

    ui = [
        VSplit(
            [
                Frame(
                    title="Delete noise until only signal remains",
                    body=Window(
                        content=BufferControl(buffer=buffer, lexer=SubcanvasLexer())
                    ),
                ),
                Frame(
                    title="Subcanvasses",
                    body=Window(width=15, content=subcanvasses_display),
                ),
            ]
        ),
        VSplit(
            [
                Window(content=FormattedTextControl(text=legend_left)),
                Window(content=FormattedTextControl(text=legend_center)),
                Window(
                    content=FormattedTextControl(text=legend_right),
                    align=WindowAlign.RIGHT,
                ),
            ]
        ),
    ]

    if args.debug:
        debug_file = open(config.runtime.debug_log, "w")
        debug(f"cog started {datetime.now()}")
        ui.append(HorizontalLine())
        ui.append(Window(content=debug_display))

    root_container = HSplit(ui)

    subcanvasses.append(Data(Kind.signal, noise))

    # start with the input noise as the signal
    buffer.text = noise

    kb = KeyBindings()

    @kb.add("c-c")
    def done(event):
        if args.debug:
            debug_dump()
        event.app.exit()

    # https://github.com/prompt-toolkit/python-prompt-toolkit/issues/502#issuecomment-466591259
    sys.stdin = sys.stderr
    app = Application(
        key_bindings=kb, layout=Layout(root_container), editing_mode=EditingMode.VI
    )
    app.vi_state.default_input_mode = InputMode.NAVIGATION
    app.vi_state.allowed_input_modes = [InputMode.NAVIGATION]
    app.reset()
    app.run()
