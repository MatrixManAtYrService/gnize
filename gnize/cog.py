"""
# Purpose

This module implements `cog`.  It's short for cognize, which is what happens in
your mind the first time that you see a new thing.  If you see that thing a
second time, you might recognize it--which is a separate sort of thing. That's
what the `recog` command line utility is for.

Presumably, the thing you want to cognize isn't alone.  Maybe it is bundled
with ads or other malware.  Maybe it it split by a pagniation boundary.
Whatevever the extra data is, we'll call the whole thing "noise" and whatever
subset you want to cognize now (and recognize later) we'll call "signal".

`cog` will create artifacts that you (or someone else) can use to identify the
signal later on--even if it is surrounded by (or lightly corruptedby ) by
different noise.

There are two components to this:

- fingerprints (stored in ~/.gnize/fingerprints.db)
- canvasses (stored in ~/.gnize/canvasses)

The fingerprints are generated by features.py, they're a list of hashes ordered
by their appearence in the noise.  Each time you cog(nize) you create a single
canvas, which is a list of strings which together make up the signal.
Canvasses aren't a single string because the signal as found in the noise might
have noise in ths middle.  For instance, here's some noise:

    asdfsdaf45646546This is the song that never ends yes it goes on
    and on my friends some people started signing it __^%%$^%k not
    knowning what it was and they'll continue singing it forever
    just because assxccjjasoadflkasdflkjsdlj.

The cognizer has some freedom in how they extract this signal, but a reasonable
choice would be:

    ["This is the song that never ends yes it goes on and on my friends some people started signing it ",
     "not knowning what it was and they'll continue singing it forever just because"]

A recognizer of the "same" signal, couched in different noise might break it up
differently, and that might corrupt some of the fingerprints that they
calculate, but unless their corruption is severe, they're likely to reidentify
enough of the same fingerprints that they can find the original canvas (and
whatever annotations go with it).

The possibility of having several canvasses for what ammounts to the "same"
signal, and building consensus on one to treat as cannonical, is a separate
problem.  For now we just want create canvasses and query for them by fingerprints.
"""

import atexit
import sys
from dataclasses import dataclass
from datetime import datetime
from enum import Enum, auto
from pprint import pformat
from textwrap import dedent, indent
from typing import Union, Tuple, Iterator

from intervaltree import Interval, IntervalTree
from prompt_toolkit import Application
from prompt_toolkit.buffer import Buffer
from prompt_toolkit.enums import EditingMode
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.layout import Layout
from prompt_toolkit.layout.containers import HSplit, VSplit, Window, WindowAlign
from prompt_toolkit.layout.controls import BufferControl, FormattedTextControl
from prompt_toolkit.widgets import Frame, HorizontalLine
from prompt_toolkit.key_binding.vi_state import InputMode, ViState
from prompt_toolkit.lexers import Lexer
from prompt_toolkit.styles.named_colors import NAMED_COLORS
from rich.console import Console, Text

from io import StringIO
from contextlib import redirect_stdout
from gnize import dotdir, features


class Kind(Enum):
    "cognized noise is either..."

    noise = auto()
    signal = auto()
    parameter = auto()


subcanvas_color = {
    Kind.signal: NAMED_COLORS["Teal"],
    Kind.noise: NAMED_COLORS["DarkGoldenRod"],
}


@dataclass
class Data:
    "Each interval of noise refers to..."

    kind: Kind
    data: Union[str, Tuple[str, str]]

    def summary(self, interval: Interval, index, cursor_start=0, cursor_stop=None):
        def bounds(interval, pt):
            if interval.begin >= pt:
                l = "["
            elif interval.begin < pt:
                l = "("
            else:
                l = ""

            if interval.end - 1 <= pt:
                r = "]"
            elif interval.end - 1 > pt:
                r = ")"
            else:
                r = ""

            debug(["bounds", cursor_start, cursor_stop, interval, pt, l, r])
            return (l, r)

        l, r = bounds(interval, cursor_start)

        if cursor_stop is None:
            if interval.contains_point(cursor_start):
                prefix = l + "*" + r
            else:
                prefix = None
        else:
            ls, rs = bounds(interval, cursor_start)
            if (
                cursor_start == interval.begin and cursor_stop == interval.end - 1
            ) or Interval(begin=cursor_start, end=cursor_stop).contains_interval(
                interval
            ):
                prefix = "[*]"
            elif interval.contains_point(cursor_start) or interval.contains_point(
                cursor_stop
            ):
                prefix = l + "*" + rs
            else:
                prefix = None

        # if the cursor isn't inside the subcanvas, display the subcanvas index
        if not prefix:
            prefix = f"{index}"

        flat = " ".join(self.data.split())
        width = len(flat)
        if width > 16:
            start = flat[:8]
            end = flat[-8:]
            connector = ".."
        elif width > 8:
            midpoint = int(width / 2)
            start = flat[:midpoint]
            end = flat[midpoint:]
            connector = ".."
        else:
            start = flat
            end = ""
            connector = ""

        debug(prefix + f"{start}{connector}{end}")
        return prefix + f"{start}{connector}{end}"


@dataclass
class Error:
    original: str
    user_change: str

    def __hash__(self):
        return (self.original + self.user_change).__hash__()

    def __lt__(self, other):
        return (self.original + self.user_change) < other


def find_targeted(orig: str, change: str) -> Tuple[Union[int, None], Union[int, None]]:
    """
    Given two strings, the first being the original and the second
    being whatever change the user applied, find the bounds of the
    change.
    """

    def find_mismatch(orig_iter: Iterator, change_iter: Iterator) -> Union[int, None]:
        "walk the iterators and indicate where they produce different values"
        i = 0
        try:
            while oc := next(orig_iter):
                try:
                    cc = next(change_iter)
                except StopIteration:
                    return i
                if oc != cc:
                    return i
                else:
                    i += 1
        except StopIteration:
            return None
        return i or None

    first_change = find_mismatch(iter(orig), iter(change))
    if first_change != None and first_change >= len(orig):
        first_change = None

    from_back = find_mismatch(reversed(orig), reversed(change))
    if from_back == None or from_back >= len(orig):
        last_change = None
    else:
        last_change = len(orig) - from_back
        if last_change >= len(orig):
            last_change = None

    debug(f"targeted from {first_change} to {last_change}")
    return first_change, last_change


def toggled(noise, _state, start, end):
    "The user has indicated a range, change the state for those chars"

    if not _state:
        # initialize al chars signal if no state is found
        return [Kind.signal for _ in noise]

    if start == end or end == None:
        return _state
    debug(f"toggling, rage: {start}, {end}")

    sig = 0
    noise = 0
    for i in range(start, end):
        if _state[i] in signal_kinds:
            sig += 1
        elif _state[i] in noise_kinds:
            noise += 1
        else:
            raise ValueError(f"What's {_state[i]}?")

    prefix = _state[:start]
    suffix = _state[end:]
    if sig > noise:
        target_state = Kind.noise
    else:
        target_state = Kind.signal

    return prefix + [target_state for _ in range(start, end)] + suffix


signal_kinds = [Kind.signal, Kind.parameter]
noise_kinds = [Kind.noise]


char_states = []
subcanvasses = []
subcanvasses_display = FormattedTextControl(text="")
gaps = []
gaps_display = FormattedTextControl(text="")
debug_display = FormattedTextControl(text="")


def charstate_str():
    return "".join([{Kind.signal: "s", Kind.noise: "n"}[x] for x in char_states])


class SubcanvasLexer(Lexer):

    char_states = None

    def lex_document(self, document):
        def get_line(lineno):

            if not SubcanvasLexer.char_states:
                raise Exception("Can't lex without subcanvas intervals")

            formatted_chars = [None] * len(document.lines[lineno])

            # how many characters are before this line?
            prev = 0
            for prev_line in range(lineno):
                prev += len(document.lines[prev_line]) + 1

            # set colors for this line
            for i, c in enumerate(document.lines[lineno]):
                char_no = prev + i
                char_kind = SubcanvasLexer.char_states[char_no]
                char_color = subcanvas_color[char_kind]
                formatted_chars[i] = (char_color, c)

            return formatted_chars

        return get_line


def update(event):
    global subcanvasses
    global subcanvasses_display
    global char_states
    global gaps
    global gaps_display
    global debug_display

    debug(buffer.text)

    # look for user changes
    begin, end = find_targeted(noise, uncolored(buffer.text))

    # update which characters are in/excluded based on what changed
    char_states = toggled(noise, char_states, begin, end)

    # show user recent changes
    intervals = get_subvanvasses(noise, char_states)
    SubcanvasLexer.char_states = char_states

    # show the user which characters are of which kind
    buffer.text = colored(intervals, noise)

    subcanvasses = sorted([x for x in intervals if x.data.kind in signal_kinds])
    gaps = sorted([x for x in intervals if x.data.kind in noise_kinds])

    debug(charstate_str())

    if event.selection_state:
        selected_from = min(
            event._Buffer__cursor_position,
            event.selection_state.original_cursor_position,
        )
        selected_to = max(
            event._Buffer__cursor_position,
            event.selection_state.original_cursor_position,
        )
        debug_display.text = f"{len(subcanvasses)} subcanvasses, {len(gaps)} gaps, selected: {selected_from}, {selected_to}"
        render(
            subcanvasses, subcanvasses_display, selected_from, cursor_stop=selected_to
        )
        render(gaps, gaps_display, selected_from, selected_to)
    else:
        cursor_position = event._Buffer__cursor_position
        debug_display.text = f"{len(subcanvasses)} subcanvasses, {len(gaps)} gaps, cursor:{cursor_position}"
        render(subcanvasses, subcanvasses_display, cursor_position)
        render(gaps, gaps_display, cursor_position)


def get_subvanvasses(noise, charstate):

    if charstate == None:
        print("foo")
    if len(noise) != len(charstate):
        raise ValueError(
            "we need a charstate for each noise char, length"
            f"mismatch: noise {len(noise)} != charstate {len(charstate)}"
        )

    it = IntervalTree()
    begin = 0
    end = 0
    next_kind = None

    def gobble(kind, begin):
        "reached kind boundary, create a subcanvas for previous stuff"
        debug(f"gobbling from {begin} to {end} for kind {kind}: {noise[begin:end]}")
        it[begin:end] = Data(kind=kind, data=noise[begin:end])
        begin = end + 1

    # for each char, maybe generate subcanvas for whatever preceeds it
    for i, _ in enumerate(noise):
        current = charstate[i]
        end = i + 1
        try:
            next_kind = charstate[i + 1]
        except IndexError:
            gobble(current, begin)

        if current and current != next_kind:
            gobble(current, begin)
            begin = i + 1

    return it


def colored(intervals, noise):
    return noise


#    sig_intervals = filter(lambda x: x.data.kind in signal_kinds, intervals)
#    gap_intervals = filter(lambda x: x.data.kind in noise_kinds, intervals)
#
#    c = Console()
#    t = Text(noise)
#    for sigint in sig_intervals:
#        t.stylize(sig_style, sigint.begin, sigint.end)
#    for gapint in gap_intervals:
#        t.stylize(gap_style, gapint.begin, gapint.end)
#
#    with StringIO() as buf, redirect_stdout(buf):
#        c.print(t)
#        ansi_colored = buf.getvalue()
#
#    return ansi_colored


def uncolored(string):
    return string


#     out = ""
#     for c in string:
#         if c in "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz":
#             out = out + c
#     return out


def render(interval_list, interval_display, cursor_start, cursor_stop=None):
    interval_display.text = "\n".join(
        [
            x.data.summary(x, i, cursor_start, cursor_stop=cursor_stop)
            for i, x in enumerate(interval_list)
        ]
    )


legend_left = dedent(
    """
    Done----Ctrl+D
    Cancel--Ctrl+C
    """
).strip("\n")

legend_center = dedent(
    """
    Editor--Ctrl+E
    """
).strip("\n")

legend_right = dedent(
    """
    Signals--Ctrl+[Shift]+S
    Gaps-----Ctrl+[Shift]+G
    """
).strip("\n")


debug_file = None


def close_debug_file():
    if debug_file:
        debug_file.close()


def debug(message):
    if debug_file:
        if type(message) is not str:
            debug_file.write("----\n")
            debug_file.write(indent(pformat(message), "    "))
            debug_file.write("\n")
        else:
            debug_file.write(dedent(message).strip() + "\n")
        debug_file.flush()


atexit.register(close_debug_file)

sig_style = "bold magenta"
gap_style = "bold cyan"

noise = ""
signal = ""
buffer = Buffer(on_text_changed=update, on_cursor_position_changed=update)

buffer_header = FormattedTextControl(
    text="Delete noise until only signal remains",
)
subcanvasses_header = FormattedTextControl(text="Signal")
gaps_header = FormattedTextControl(text="Noise")

selected_idx = 0

root_container = None
config = dotdir.make_or_get()


def make_canvas(_noise, args):

    global noise
    global debug_file
    global root_container

    noise = _noise
    charstate = [Kind.signal for _ in _noise]

    ui = [
        VSplit(
            [
                Frame(
                    title="Delete noise until only signal remains",
                    body=Window(
                        content=BufferControl(buffer=buffer, lexer=SubcanvasLexer())
                    ),
                ),
                Frame(
                    title="Signals",
                    body=Window(width=15, content=subcanvasses_display),
                ),
                Frame(title="Gaps", body=Window(width=10, content=gaps_display)),
            ]
        ),
        VSplit(
            [
                Window(content=FormattedTextControl(text=legend_left)),
                Window(content=FormattedTextControl(text=legend_center)),
                Window(
                    content=FormattedTextControl(text=legend_right),
                    align=WindowAlign.RIGHT,
                ),
            ]
        ),
    ]

    if args.debug:
        debug_file = open(config.runtime.debug_log, "w")
        debug(f"cog started {datetime.now()}")
        ui.append(HorizontalLine())
        ui.append(Window(content=debug_display))

    root_container = HSplit(ui)

    subcanvasses.append(Data(Kind.signal, noise))

    # start with the input noise as the signal
    buffer.text = noise

    kb = KeyBindings()

    @kb.add("c-c")
    def done(event):
        event.app.exit()

    # https://github.com/prompt-toolkit/python-prompt-toolkit/issues/502#issuecomment-466591259
    sys.stdin = sys.stderr
    app = Application(
        key_bindings=kb, layout=Layout(root_container), editing_mode=EditingMode.VI
    )
    app.vi_state.default_input_mode = InputMode.NAVIGATION
    app.reset()
    app.run()
