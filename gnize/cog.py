"""
# Purpose

This module implements `cog`.  It's short for cognize, which is what happens in
your mind the first time that you see a new thing.  If you see that thing a
second time, you might recognize it--which is a separate sort of thing. That's
what the `recog` command line utility is for.

Presumably, the thing you want to cognize isn't alone.  Maybe it is bundled
with ads or other malware.  Maybe it it split by a pagniation boundary.
Whatevever the extra data is, we'll call the whole thing "noise" and whatever
subset you want to cognize now (and recognize later) we'll call "signal".

`cog` will create artifacts that you (or someone else) can use to identify the
signal later on--even if it is surrounded by (or lightly corruptedby ) by
different noise.

There are two components to this:

- fingerprints (stored in ~/.gnize/fingerprints.db)
- canvasses (stored in ~/.gnize/canvasses)

The fingerprints are generated by features.py, they're a list of hashes ordered
by their appearence in the noise.  Each time you cog(nize) you create a single
canvas, which is a list of strings which together make up the signal.
Canvasses aren't a single string because the signal as found in the noise might
have noise in ths middle.  For instance, here's some noise:

    asdfsdaf45646546This is the song that never ends yes it goes on
    and on my friends some people started signing it __^%%$^%k not
    knowning what it was and they'll continue singing it forever
    just because assxccjjasoadflkasdflkjsdlj.

The cognizer has some freedom in how they extract this signal, but a reasonable
choice would be:

    ["This is the song that never ends yes it goes on and on my friends some people started signing it ",
     "not knowning what it was and they'll continue singing it forever just because"]

A recognizer of the "same" signal, couched in different noise might break it up
differently, and that might corrupt some of the fingerprints that they
calculate, but unless their corruption is severe, they're likely to reidentify
enough of the same fingerprints that they can find the original canvas (and
whatever annotations go with it).

The possibility of having several canvasses for what ammounts to the "same"
signal, and building consensus on one to treat as cannonical, is a separate
problem.  For now we just want create canvasses and query for them by fingerprints.
"""

import atexit
import sys
from contextlib import redirect_stdout
from dataclasses import dataclass
from datetime import datetime
from enum import Enum, auto
from io import StringIO
from pprint import pformat
from textwrap import dedent, indent
from typing import Iterator, List, Tuple, Union

import yaml
from intervaltree import Interval, IntervalTree
from tabulate import tabulate

from gnize import dotdir
from prompt_toolkit import Application
from prompt_toolkit.buffer import Buffer
from prompt_toolkit.document import Document
from prompt_toolkit.enums import EditingMode
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.key_binding.vi_state import InputMode
from prompt_toolkit.layout import Layout
from prompt_toolkit.layout.containers import HSplit, VSplit, Window, WindowAlign
from prompt_toolkit.layout.controls import BufferControl, FormattedTextControl
from prompt_toolkit.lexers import Lexer
from prompt_toolkit.widgets import Frame, HorizontalLine


class Kind(Enum):
    "cognized noise is either..."

    noise = auto()
    signal = auto()
    parameter = auto()


subcanvas_color = {
    Kind.signal: "#B5B900",
    Kind.parameter: "#2aa198",
    Kind.noise: "#586e75",
}


@dataclass
class CharState:
    selected: bool
    kind: Kind
    char: str
    styled_char: Tuple[str, str]


@dataclass
class Data:
    "Each interval of noise refers to..."

    kind: Kind
    data: Union[str, Tuple[str, str]]

    def summary(
        self, interval: Interval, cursor_start=0, cursor_stop=None
    ) -> List[CharState]:

        selection_end = cursor_stop or cursor_start or 1
        selection = Interval(begin=cursor_start or 0, end=cursor_stop or cursor_start)
        unabridged = []
        for i, c in enumerate(interval.data.data):
            idx = i + interval.begin
            if c.isspace():
                c = " "

            selected = selection.contains_point(idx)

            color = subcanvas_color[interval.data.kind]
            if selected:
                color = f"{color} bold"

            unabridged.append(
                CharState(
                    selected=selected,
                    kind=interval.data.kind,
                    char=c,
                    styled_char=(color, c),
                )
            )

        width = 10
        part = int(width / 2) - 1

        if len(unabridged) > width:
            start = unabridged[:part]
            end = unabridged[-part:]
            omitted = unabridged[part:-part]

            if any(filter(lambda x: x.selected, omitted)):
                standin_selected = True
            else:
                standin_selected = False

            if any(filter(lambda x: x.kind == Kind.signal, unabridged)):
                standin_kind = Kind.signal
            else:
                standin_kind = Kind.noise

            standin = [
                CharState(
                    selected=standin_selected,
                    kind=standin_kind,
                    char="...",
                    styled_char=(subcanvas_color[standin_kind], "..."),
                )
            ]

        else:
            start = unabridged
            end = []
            standin = []

        return start + standin + end


@dataclass
class Error:
    original: str
    user_change: str

    def __hash__(self):
        return (self.original + self.user_change).__hash__()

    def __lt__(self, other):
        return (self.original + self.user_change) < other


def find_targeted(
    orig: str, change: str, cursor_pos: int, prev_cursor_pos: int
) -> Tuple[Union[int, None], Union[int, None], Union[int, None]]:
    """
    Given two strings, the first being the original and the second
    being whatever change the user applied, find the bounds of the
    change.
    """

    new_cursor_pos = None

    def find_mismatch(orig_iter: Iterator, change_iter: Iterator) -> Union[int, None]:
        "walk the iterators and indicate where they produce different values"
        i = 0
        try:
            while oc := next(orig_iter):
                try:
                    cc = next(change_iter)
                except StopIteration:
                    return i
                if oc != cc:
                    return i
                else:
                    i += 1
        except StopIteration:
            return None
        return i or None

    delta = len(orig) - len(change)
    if not delta:
        first_change = last_change = None
    else:

        first_change = find_mismatch(iter(orig), iter(change))
        if first_change != None and first_change >= len(orig):
            first_change = None

        from_back = find_mismatch(reversed(orig), reversed(change))
        if from_back == None or from_back >= len(orig):
            last_change = None
        else:
            last_change = len(orig) - from_back
            if last_change >= len(orig):
                last_change = None

        first_change = first_change or 0
        last_change = last_change or len(orig) - 1

        if last_change <= first_change:
            debug(
                f"naievely got {first_change} to {last_change}, length_delta: {delta} "
                f"Resolving via: cursor_pos {cursor_pos}->{prev_cursor_pos}"
            )
            if cursor_pos >= prev_cursor_pos:
                first_change = cursor_pos
                last_change = cursor_pos + delta
                new_cursor_pos = None
            else:
                last_change = prev_cursor_pos
                first_change = prev_cursor_pos - delta
                new_cursor_pos = None

    debug(
        f"targeted from {first_change} to {last_change}, cursor_pos {cursor_pos}->{prev_cursor_pos}"
    )
    return first_change, last_change, new_cursor_pos


def toggled(noise, _state, start, end) -> List[Kind]:
    "The user has indicated a range, change the state for those chars"

    if not _state:
        # initialize all chars as signal if no state is found
        return [Kind.signal for _ in noise]

    if start == end or end == None:
        return _state
    debug(f"toggling, rage: {start}, {end}")

    sig = 0
    noise = 0
    for i in range(start, end):
        if _state[i] in signal_kinds:
            sig += 1
        elif _state[i] in noise_kinds:
            noise += 1
        else:
            raise ValueError(f"What's {_state[i]}?")

    prefix = _state[:start]
    suffix = _state[end:]
    debug(f"sigs in toggle: {sig}")
    debug(f"noise in toggle: {noise}")
    if sig:
        target_state = Kind.noise
    else:
        target_state = Kind.signal

    return prefix + [target_state for _ in range(start, end)] + suffix


signal_kinds = [Kind.signal, Kind.parameter]
noise_kinds = [Kind.noise]


prev_char_states = []
char_states = []
debug_display = FormattedTextControl(text="")


def charstate_str():
    return "".join([{Kind.signal: "s", Kind.noise: "n"}[x] for x in char_states])


class SubcanvasLexer(Lexer):

    char_states: List[Kind] = []

    def lex_document(self, document):
        def get_line(lineno):

            line_start = line_start_idx[lineno]

            formatted_chars = [None] * len(document.lines[lineno])

            # set colors for this line
            for i, c in enumerate(document.lines[lineno]):
                char_no = line_start + i
                char_kind = SubcanvasLexer.char_states[char_no]
                char_color = subcanvas_color[char_kind]
                formatted_chars[i] = (char_color, c)

            return formatted_chars

        return get_line


class SubcanvasSummaryLexer(Lexer):

    cursor_start = 0
    cursor_stop = None
    it: IntervalTree = None

    def lex_document(self, document):
        def get_line(lineno):
            interval = sorted(SubcanvasSummaryLexer.it)[lineno]
            summary = interval.data.summary(
                interval,
                cursor_start=SubcanvasSummaryLexer.cursor_start,
                cursor_stop=SubcanvasSummaryLexer.cursor_stop,
            )

            return [s.styled_char for s in summary]

        return get_line


def format_event(event, previous_event=None):
    # shortens event for debug display
    def show(kv):
        k, v = kv
        if not str(v):
            return False
        if str(v)[-1] == ">":
            return False
        if str(v) == "None":
            return False
        if "do_stack" in k:
            return False
        if "validation" in k:
            return False
        if "completer" in k:
            return False
        if "_document_cache" in k:
            return False
        return True

    with StringIO() as buf, redirect_stdout(buf):
        print("event:")
        if not previous_event:
            tbl = list(map(list, filter(show, event.__dict__.items())))
            tbl_out = tabulate(tbl)
            tbl_out_simpler = "\n".join(tbl_out.split("\n")[1:-1])
            print(indent(tbl_out_simpler, prefix="    "))
        return buf.getvalue()


subcanvasses = []
subcanvas_summaries = Buffer()
subcanvasses_display = BufferControl(
    buffer=subcanvas_summaries, lexer=SubcanvasSummaryLexer()
)

cursor_pos = 0
prev_cursor_pos = 0
reentrancy = 0
iterations = 0

prev_event = None
prev_selection_ranges = None


def update(event):
    global subcanvasses
    global subcanvasses_display
    global subcanvas_summaries
    global prev_char_states
    global char_states
    global debug_display
    global debug_buffer
    global cursor_pos
    global prev_cursor_pos
    global reentrancy
    global prev_event
    global iterations
    global pending_debug_buffer
    global prev_selection_ranges

    # if this event's handler causes it to fire again before it is handled,
    # skip most of the handler until the first handling is completed
    reentrancy += 1
    if reentrancy == 1:
        iterations += 1

        try:

            debug(f"iteration: {iterations}")
            debug(format_event(event))

            selection_ranges = list(event.document.selection_ranges())
            debug(f"selection: {selection_ranges}")
            if prev_selection_ranges:
                debug(f"prevous selection: {prev_selection_ranges}")

            # look for user changes
            begin, end, cursor_position_override = find_targeted(
                noise, buffer.text, cursor_pos, prev_cursor_pos
            )

            # update which characters are in/excluded based on what changed
            debug("char_states: " + str(char_states))
            char_states = toggled(noise, char_states, begin, end)

            # show user recent changes
            try:
                intervals = get_subcanvasses(noise, char_states)
            except AlignmentError as err:
                debug_next(str(err))
                buffer.text = noise
                char_states = prev_char_states
            else:

                SubcanvasLexer.char_states = char_states
                SubcanvasSummaryLexer.it = intervals

                # show the user which characters are of which kind
                buffer.text = noise

                subcanvasses = sorted(intervals)

                def update_subcanvas_summaries(cursor_start, cursor_stop=None):
                    global subcanvas_summaries

                debug("charstate: " + charstate_str())

                # color summaries based on current selection
                if event.selection_state:
                    SubcanvasSummaryLexer.cursor_start = min(
                        event._Buffer__cursor_position,
                        event.selection_state.original_cursor_position,
                    )
                    SubcanvasSummaryLexer.cursor_stop = max(
                        event._Buffer__cursor_position,
                        event.selection_state.original_cursor_position,
                    )
                else:
                    SubcanvasSummaryLexer.cursor_start = event._Buffer__cursor_position

                # give interval starts, lexer will replace each with a summary
                interval_starts = []
                for subcanvas in subcanvasses:
                    interval_starts.append(str(subcanvas.begin))
                subcanvas_summaries.text = "\n".join(interval_starts)

                if not cursor_position_override:
                    if end and end > event._Buffer__cursor_position:
                        debug(f"setting cursor_position: {end}")
                        cursor_position_override = end

                # set cursor position
                buffer.cursor_position = (
                    cursor_position_override or event._Buffer__cursor_position
                )
                prev_cursor_pos = cursor_pos
                cursor_pos = buffer.cursor_position

        except Exception as ex:
            # don't hide debug data just because we got an exception
            print(pending_debug_buffer)
            print(debug_buffer)
            raise ex

    # run at the end of the outermost call
    reentrancy -= 1
    if not reentrancy:

        # populate debug_display
        debug_display.text = debug_buffer
        debug_buffer = "" or pending_debug_buffer
        if pending_debug_buffer:
            pending_debug_buffer = ""

        prev_event = event
        prev_char_states = char_states
        prev_selection_ranges = selection_ranges


class Direction(Enum):
    back = auto()
    forward = auto()


class AlignmentError(Exception):
    pass


def get_subcanvasses(noise, charstate) -> IntervalTree:

    if charstate == None:
        charstate = [Kind.signal] * len(noise)

    if len(noise) != len(charstate):
        raise AlignmentError(
            dedent(
                f"""
                we need a charstate for each noise char
                {noise} (len: {len(noise)})
                  !=
                {char_states} (len: {len(char_states)})
                """
            )
        )

    it = IntervalTree()
    begin = 0
    end = 0
    next_kind = None

    def gobble(kind, begin):
        "reached kind boundary, create a subcanvas for previous stuff"
        debug(f"gobbling from {begin} to {end} for {kind}:")
        debug(indent(noise[begin:end], prefix="    "))

        it[begin:end] = Data(kind=kind, data=noise[begin:end])
        begin = end + 1

    # for each char, maybe generate subcanvas for whatever preceeds it
    for i, _ in enumerate(noise):
        current = charstate[i]
        end = i + 1
        try:
            next_kind = charstate[i + 1]
        except IndexError:
            gobble(current, begin)

        if current and current != next_kind:
            gobble(current, begin)
            begin = i + 1

    return it


legend_left = dedent(
    """
    Done----Ctrl+D
    Cancel--Ctrl+C
    """
).strip("\n")

legend_center = dedent(
    """
    Editor--Ctrl+E
    """
).strip("\n")

legend_right = dedent(
    """
    Signals--Ctrl+[Shift]+S
    Gaps-----Ctrl+[Shift]+G
    """
).strip("\n")


debug_file = None


def close_debug_file():
    if debug_file:
        debug_file.close()


pending_debug_buffer = ""
debug_buffer = ""


def debug_next(message):
    global pending_debug_buffer

    if message[-1] != "\n":
        message += "\n"
    pending_debug_buffer += str(message)


def debug(message):
    global debug_buffer

    if message[-1] != "\n":
        message += "\n"

    if debug_file:
        if type(message) is not str:
            debug_file.write("----\n")
            debug_file.write(indent(pformat(message), prefix="    "))
            debug_file.write("\n\n")
        else:
            debug_file.write(dedent(message).strip() + "\n\n")
        debug_file.flush()
    debug_buffer += str(message)


def debug_dump():
    with open(config.runtime.debug_obj, "w") as f:
        f.write(
            yaml.dump(
                {
                    "states": list(
                        map(list, zip(noise, [x.name for x in char_states]))
                    ),
                    "subcanvasses": [x.data.data for x in subcanvasses],
                }
            )
        )


atexit.register(close_debug_file)

noise = ""
line_start_idx = {}
signal = ""
buffer = Buffer(on_text_changed=update, on_cursor_position_changed=update)

buffer_header = FormattedTextControl(
    text="Delete noise until only signal remains",
)
subcanvasses_header = FormattedTextControl(text="Signal")

selected_idx = 0

root_container = None
config = dotdir.make_or_get()


app = None


def make_canvas(_noise, args):

    global noise
    global debug_file
    global root_container

    noise = _noise  # + "\n"

    # lexers care about line numbers, so cache them
    idx = 0
    for i, n in enumerate(noise.split("\n")):
        line_start_idx[i] = idx
        idx = idx + len(n) + 1

    charstate = [Kind.signal for _ in _noise]

    ui = [
        VSplit(
            [
                Frame(
                    title="Delete noise until only signal remains",
                    body=Window(
                        content=BufferControl(buffer=buffer, lexer=SubcanvasLexer())
                    ),
                ),
                Frame(
                    title="Subcanvasses",
                    body=Window(width=15, content=subcanvasses_display),
                ),
            ]
        ),
        VSplit(
            [
                Window(content=FormattedTextControl(text=legend_left)),
                Window(content=FormattedTextControl(text=legend_center)),
                Window(
                    content=FormattedTextControl(text=legend_right),
                    align=WindowAlign.RIGHT,
                ),
            ]
        ),
    ]

    if args.debug:
        debug_file = open(config.runtime.debug_log, "w")
        debug(f"cog started {datetime.now()}")
        ui.append(HorizontalLine())
        ui.append(Window(content=debug_display))

    root_container = HSplit(ui)

    subcanvasses.append(Data(Kind.signal, noise))

    # start with the input noise as the signal
    buffer.text = noise

    kb = KeyBindings()

    @kb.add("c-c")
    def done(event):
        if args.debug:
            debug_dump()
        event.app.exit()

    # https://github.com/prompt-toolkit/python-prompt-toolkit/issues/502#issuecomment-466591259
    sys.stdin = sys.stderr
    app = Application(
        key_bindings=kb, layout=Layout(root_container), editing_mode=EditingMode.VI
    )
    app.vi_state.default_input_mode = InputMode.NAVIGATION
    app.vi_state.allowed_input_modes = [InputMode.NAVIGATION]
    app.reset()
    app.run()
